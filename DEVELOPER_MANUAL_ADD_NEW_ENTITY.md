# EntitiesManager Microservice - Developer Manual: Adding New Entity Types

## Table of Contents
1. [Overview](#overview)
2. [Entity Creation Process](#entity-creation-process)
3. [Repository Layer Implementation](#repository-layer-implementation)
4. [API Layer Integration](#api-layer-integration)
5. [MassTransit Message Bus Integration](#masstransit-message-bus-integration)
6. [OpenTelemetry Integration](#opentelemetry-integration)
7. [Testing Implementation](#testing-implementation)
8. [Step-by-Step Example: ProcessorEntity](#step-by-step-example-processorentity)

## Overview

This manual provides a comprehensive guide for adding new entity types to the EntitiesManager microservice. The system follows established patterns using MongoDB.Driver, System.Guid primary keys, MassTransit message bus, and comprehensive OpenTelemetry observability.

### Key Architectural Principles
- **No DTOs/AutoMapper**: Direct entity usage throughout the application
- **MongoDB.Driver**: Direct MongoDB integration with auto-generated GUIDs
- **System.Guid Primary Keys**: Auto-generated by MongoDB using BSON configuration
- **MassTransit Integration**: 4 consumers per entity type (Create, Update, Delete, Get)
- **OpenTelemetry Observability**: Comprehensive logging, metrics, and tracing
- **Real Container Testing**: Integration tests against actual Docker containers

## Entity Creation Process

### 1. Create Entity Class in Core Layer

**Location**: `src/EntitiesManager/EntitiesManager.Core/Entities/`

```csharp
using EntitiesManager.Core.Entities.Base;
using MongoDB.Bson.Serialization.Attributes;
using System.ComponentModel.DataAnnotations;

namespace EntitiesManager.Core.Entities;

public class ProcessorEntity : BaseEntity
{
    [BsonElement("name")]
    [Required(ErrorMessage = "Name is required")]
    [StringLength(200, ErrorMessage = "Name cannot exceed 200 characters")]
    public string Name { get; set; } = string.Empty;

    [BsonElement("version")]
    [Required(ErrorMessage = "Version is required")]
    [StringLength(50, ErrorMessage = "Version cannot exceed 50 characters")]
    public string Version { get; set; } = string.Empty;

    [BsonElement("processorType")]
    [Required(ErrorMessage = "Processor type is required")]
    [StringLength(100, ErrorMessage = "Processor type cannot exceed 100 characters")]
    public string ProcessorType { get; set; } = string.Empty;

    [BsonElement("configuration")]
    public Dictionary<string, object> Configuration { get; set; } = new();

    [BsonElement("isActive")]
    public bool IsActive { get; set; } = true;

    // Required: Implement composite key for uniqueness validation
    public override string GetCompositeKey() => $"{Name}_{Version}";
}
```

### 2. Required Attributes and Inheritance

**BaseEntity Inheritance**: All entities must inherit from `BaseEntity` which provides:
- `[BsonId]` and `[BsonRepresentation(BsonType.String)]` for auto-generated GUID IDs
- Standard audit fields: `CreatedAt`, `UpdatedAt`, `CreatedBy`, `UpdatedBy`
- Abstract `GetCompositeKey()` method for uniqueness validation

**Required Attributes**:
- `[BsonElement("fieldName")]`: Maps properties to MongoDB document fields
- `[Required]`: Data validation attributes
- `[StringLength]`: Field length validation
- Custom validation attributes as needed

### 3. MongoDB BSON Configuration

**Location**: `src/EntitiesManager/EntitiesManager.Infrastructure/MongoDB/BsonConfiguration.cs`

Add your entity to the BSON configuration:

```csharp
if (!BsonClassMap.IsClassMapRegistered(typeof(ProcessorEntity)))
{
    BsonClassMap.RegisterClassMap<ProcessorEntity>(cm =>
    {
        cm.AutoMap();
        cm.SetIgnoreExtraElements(true);
    });
}
```

### 4. Create Repository Interface

**Location**: `src/EntitiesManager/EntitiesManager.Core/Interfaces/Repositories/`

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Interfaces.Repositories.Base;

namespace EntitiesManager.Core.Interfaces.Repositories;

public interface IProcessorEntityRepository : IBaseRepository<ProcessorEntity>
{
    // Add any entity-specific repository methods here
    Task<IEnumerable<ProcessorEntity>> GetByProcessorTypeAsync(string processorType);
    Task<IEnumerable<ProcessorEntity>> GetActiveProcessorsAsync();
}
```

## Repository Layer Implementation

### 1. Create Repository Implementation

**Location**: `src/EntitiesManager/EntitiesManager.Infrastructure/Repositories/`

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Core.Interfaces.Services;
using EntitiesManager.Infrastructure.MassTransit.Events;
using Microsoft.Extensions.Logging;
using MongoDB.Driver;

namespace EntitiesManager.Infrastructure.Repositories;

public class ProcessorEntityRepository : BaseRepository<ProcessorEntity>, IProcessorEntityRepository
{
    public ProcessorEntityRepository(IMongoDatabase database, ILogger<ProcessorEntityRepository> logger, IEventPublisher eventPublisher)
        : base(database, "processors", logger, eventPublisher)
    {
    }

    // Implement entity-specific methods
    public async Task<IEnumerable<ProcessorEntity>> GetByProcessorTypeAsync(string processorType)
    {
        var filter = Builders<ProcessorEntity>.Filter.Eq(x => x.ProcessorType, processorType);
        return await _collection.Find(filter).ToListAsync();
    }

    public async Task<IEnumerable<ProcessorEntity>> GetActiveProcessorsAsync()
    {
        var filter = Builders<ProcessorEntity>.Filter.Eq(x => x.IsActive, true);
        return await _collection.Find(filter).ToListAsync();
    }

    // Required: Implement abstract methods from BaseRepository
    protected override FilterDefinition<ProcessorEntity> CreateCompositeKeyFilter(string compositeKey)
    {
        var parts = compositeKey.Split('_');
        if (parts.Length != 2) throw new ArgumentException("Invalid composite key format");

        return Builders<ProcessorEntity>.Filter.And(
            Builders<ProcessorEntity>.Filter.Eq(x => x.Name, parts[0]),
            Builders<ProcessorEntity>.Filter.Eq(x => x.Version, parts[1])
        );
    }

    protected override void CreateIndexes()
    {
        // Create composite key index for uniqueness
        var compositeKeyIndex = Builders<ProcessorEntity>.IndexKeys
            .Ascending(x => x.Name)
            .Ascending(x => x.Version);

        _collection.Indexes.CreateOne(new CreateIndexModel<ProcessorEntity>(
            compositeKeyIndex,
            new CreateIndexOptions { Unique = true, Name = "idx_processor_composite_key" }
        ));

        // Create additional indexes for common queries
        var processorTypeIndex = Builders<ProcessorEntity>.IndexKeys.Ascending(x => x.ProcessorType);
        _collection.Indexes.CreateOne(new CreateIndexModel<ProcessorEntity>(
            processorTypeIndex,
            new CreateIndexOptions { Name = "idx_processor_type" }
        ));

        var isActiveIndex = Builders<ProcessorEntity>.IndexKeys.Ascending(x => x.IsActive);
        _collection.Indexes.CreateOne(new CreateIndexModel<ProcessorEntity>(
            isActiveIndex,
            new CreateIndexOptions { Name = "idx_processor_active" }
        ));
    }

    // Required: Implement event publishing methods
    protected override async Task PublishCreatedEventAsync(ProcessorEntity entity)
    {
        await _eventPublisher.PublishAsync(new ProcessorCreatedEvent
        {
            Id = entity.Id,
            Name = entity.Name,
            Version = entity.Version,
            ProcessorType = entity.ProcessorType,
            Configuration = entity.Configuration,
            IsActive = entity.IsActive,
            CreatedAt = entity.CreatedAt,
            CreatedBy = entity.CreatedBy
        });
    }

    protected override async Task PublishUpdatedEventAsync(ProcessorEntity entity)
    {
        await _eventPublisher.PublishAsync(new ProcessorUpdatedEvent
        {
            Id = entity.Id,
            Name = entity.Name,
            Version = entity.Version,
            ProcessorType = entity.ProcessorType,
            Configuration = entity.Configuration,
            IsActive = entity.IsActive,
            UpdatedAt = entity.UpdatedAt,
            UpdatedBy = entity.UpdatedBy
        });
    }

    protected override async Task PublishDeletedEventAsync(Guid id, string deletedBy)
    {
        await _eventPublisher.PublishAsync(new ProcessorDeletedEvent
        {
            Id = id,
            DeletedAt = DateTime.UtcNow,
            DeletedBy = deletedBy
        });
    }
}
```

### 2. Register Repository in DI Container

**Location**: `src/EntitiesManager/EntitiesManager.Api/Configuration/MongoDbConfiguration.cs`

Add to the `AddMongoDb` method:

```csharp
// Register repositories
services.AddScoped<IProcessorEntityRepository, ProcessorEntityRepository>();
```

## API Layer Integration

### 1. Create Controller

**Location**: `src/EntitiesManager/EntitiesManager.Api/Controllers/`

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Exceptions;
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MassTransit.Events;
using MassTransit;
using Microsoft.AspNetCore.Mvc;

namespace EntitiesManager.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ProcessorsController : ControllerBase
{
    private readonly IProcessorEntityRepository _repository;
    private readonly ILogger<ProcessorsController> _logger;
    private readonly IPublishEndpoint _publishEndpoint;

    public ProcessorsController(
        IProcessorEntityRepository repository,
        ILogger<ProcessorsController> logger,
        IPublishEndpoint publishEndpoint)
    {
        _repository = repository;
        _logger = logger;
        _publishEndpoint = publishEndpoint;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<ProcessorEntity>>> GetAll()
    {
        try
        {
            var entities = await _repository.GetAllAsync();
            return Ok(entities);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving all ProcessorEntities");
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpGet("{id:guid}")]
    public async Task<ActionResult<ProcessorEntity>> GetById(Guid id)
    {
        try
        {
            var entity = await _repository.GetByIdAsync(id);
            if (entity == null)
                return NotFound();

            return Ok(entity);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving ProcessorEntity with ID {Id}", id);
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpGet("by-type/{processorType}")]
    public async Task<ActionResult<IEnumerable<ProcessorEntity>>> GetByProcessorType(string processorType)
    {
        try
        {
            var entities = await _repository.GetByProcessorTypeAsync(processorType);
            return Ok(entities);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving ProcessorEntities by type {ProcessorType}", processorType);
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpGet("active")]
    public async Task<ActionResult<IEnumerable<ProcessorEntity>>> GetActiveProcessors()
    {
        try
        {
            var entities = await _repository.GetActiveProcessorsAsync();
            return Ok(entities);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving active ProcessorEntities");
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpPost]
    public async Task<ActionResult<ProcessorEntity>> Create([FromBody] ProcessorEntity entity)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        try
        {
            entity.CreatedBy = User.Identity?.Name ?? "System";
            entity.Id = Guid.Empty; // Ensure MongoDB generates the ID

            var created = await _repository.CreateAsync(entity);

            if (created.Id == Guid.Empty)
            {
                _logger.LogError("MongoDB failed to generate ID for new ProcessorEntity");
                return StatusCode(500, "Failed to generate entity ID");
            }

            // Event publishing is handled by the repository
            return CreatedAtAction(nameof(GetById), new { id = created.Id }, created);
        }
        catch (DuplicateKeyException ex)
        {
            return Conflict(new { message = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating ProcessorEntity");
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpPut("{id:guid}")]
    public async Task<ActionResult<ProcessorEntity>> Update(Guid id, [FromBody] ProcessorEntity entity)
    {
        if (!ModelState.IsValid)
            return BadRequest(ModelState);

        if (id != entity.Id)
            return BadRequest("ID mismatch");

        try
        {
            entity.UpdatedBy = User.Identity?.Name ?? "System";
            var updated = await _repository.UpdateAsync(entity);

            if (updated == null)
                return NotFound();

            return Ok(updated);
        }
        catch (DuplicateKeyException ex)
        {
            return Conflict(new { message = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating ProcessorEntity with ID {Id}", id);
            return StatusCode(500, "Internal server error");
        }
    }

    [HttpDelete("{id:guid}")]
    public async Task<IActionResult> Delete(Guid id)
    {
        try
        {
            var deleted = await _repository.DeleteAsync(id);
            if (!deleted)
                return NotFound();

            return NoContent();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting ProcessorEntity with ID {Id}", id);
            return StatusCode(500, "Internal server error");
        }
    }
}
```

### 2. HTTP Endpoints Summary

The controller provides the following REST endpoints:

- `GET /api/processors` - Get all processors
- `GET /api/processors/{id}` - Get processor by ID
- `GET /api/processors/by-type/{processorType}` - Get processors by type
- `GET /api/processors/active` - Get active processors only
- `POST /api/processors` - Create new processor
- `PUT /api/processors/{id}` - Update existing processor
- `DELETE /api/processors/{id}` - Delete processor

## MassTransit Message Bus Integration

### 1. Create Commands

**Location**: `src/EntitiesManager/EntitiesManager.Infrastructure/MassTransit/Commands/`

Create `ProcessorCommands.cs`:

```csharp
namespace EntitiesManager.Infrastructure.MassTransit.Commands;

public class CreateProcessorCommand
{
    public string Name { get; set; } = string.Empty;
    public string Version { get; set; } = string.Empty;
    public string ProcessorType { get; set; } = string.Empty;
    public Dictionary<string, object> Configuration { get; set; } = new();
    public bool IsActive { get; set; } = true;
    public string RequestedBy { get; set; } = string.Empty;
}

public class UpdateProcessorCommand
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Version { get; set; } = string.Empty;
    public string ProcessorType { get; set; } = string.Empty;
    public Dictionary<string, object> Configuration { get; set; } = new();
    public bool IsActive { get; set; } = true;
    public string RequestedBy { get; set; } = string.Empty;
}

public class DeleteProcessorCommand
{
    public Guid Id { get; set; }
    public string RequestedBy { get; set; } = string.Empty;
}

public class GetProcessorQuery
{
    public Guid Id { get; set; }
}
```

### 2. Create Events

**Location**: `src/EntitiesManager/EntitiesManager.Infrastructure/MassTransit/Events/`

Create `ProcessorEvents.cs`:

```csharp
namespace EntitiesManager.Infrastructure.MassTransit.Events;

public class ProcessorCreatedEvent
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Version { get; set; } = string.Empty;
    public string ProcessorType { get; set; } = string.Empty;
    public Dictionary<string, object> Configuration { get; set; } = new();
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
    public string CreatedBy { get; set; } = string.Empty;
}

public class ProcessorUpdatedEvent
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Version { get; set; } = string.Empty;
    public string ProcessorType { get; set; } = string.Empty;
    public Dictionary<string, object> Configuration { get; set; } = new();
    public bool IsActive { get; set; }
    public DateTime UpdatedAt { get; set; }
    public string UpdatedBy { get; set; } = string.Empty;
}

public class ProcessorDeletedEvent
{
    public Guid Id { get; set; }
    public DateTime DeletedAt { get; set; }
    public string DeletedBy { get; set; } = string.Empty;
}
```

### 3. Create Consumers (4 per Entity Type)

Following the user preference for separating destination and source consumers into different folders, create:

**Location**: `src/EntitiesManager/EntitiesManager.Infrastructure/MassTransit/Consumers/Processor/`

#### CreateProcessorCommandConsumer.cs

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Exceptions;
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MassTransit.Commands;
using EntitiesManager.Infrastructure.MassTransit.Events;
using MassTransit;
using Microsoft.Extensions.Logging;

namespace EntitiesManager.Infrastructure.MassTransit.Consumers.Processor;

public class CreateProcessorCommandConsumer : IConsumer<CreateProcessorCommand>
{
    private readonly IProcessorEntityRepository _repository;
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly ILogger<CreateProcessorCommandConsumer> _logger;

    public CreateProcessorCommandConsumer(
        IProcessorEntityRepository repository,
        IPublishEndpoint publishEndpoint,
        ILogger<CreateProcessorCommandConsumer> logger)
    {
        _repository = repository;
        _publishEndpoint = publishEndpoint;
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<CreateProcessorCommand> context)
    {
        _logger.LogInformation("Processing CreateProcessorCommand for {Name}_{Version}",
            context.Message.Name, context.Message.Version);

        try
        {
            var entity = new ProcessorEntity
            {
                Name = context.Message.Name,
                Version = context.Message.Version,
                ProcessorType = context.Message.ProcessorType,
                Configuration = context.Message.Configuration ?? new Dictionary<string, object>(),
                IsActive = context.Message.IsActive,
                CreatedBy = context.Message.RequestedBy
            };

            var created = await _repository.CreateAsync(entity);

            await _publishEndpoint.Publish(new ProcessorCreatedEvent
            {
                Id = created.Id,
                Name = created.Name,
                Version = created.Version,
                ProcessorType = created.ProcessorType,
                Configuration = created.Configuration,
                IsActive = created.IsActive,
                CreatedAt = created.CreatedAt,
                CreatedBy = created.CreatedBy
            });

            await context.RespondAsync(created);

            _logger.LogInformation("Successfully processed CreateProcessorCommand for {Name}_{Version}",
                context.Message.Name, context.Message.Version);
        }
        catch (DuplicateKeyException ex)
        {
            _logger.LogWarning("Duplicate key error in CreateProcessorCommand: {Error}", ex.Message);
            await context.RespondAsync(new { Error = ex.Message, Success = false });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing CreateProcessorCommand for {Name}_{Version}",
                context.Message.Name, context.Message.Version);
            throw;
        }
    }
}
```

#### UpdateProcessorCommandConsumer.cs

```csharp
using EntitiesManager.Core.Exceptions;
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MassTransit.Commands;
using EntitiesManager.Infrastructure.MassTransit.Events;
using MassTransit;
using Microsoft.Extensions.Logging;

namespace EntitiesManager.Infrastructure.MassTransit.Consumers.Processor;

public class UpdateProcessorCommandConsumer : IConsumer<UpdateProcessorCommand>
{
    private readonly IProcessorEntityRepository _repository;
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly ILogger<UpdateProcessorCommandConsumer> _logger;

    public UpdateProcessorCommandConsumer(
        IProcessorEntityRepository repository,
        IPublishEndpoint publishEndpoint,
        ILogger<UpdateProcessorCommandConsumer> logger)
    {
        _repository = repository;
        _publishEndpoint = publishEndpoint;
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<UpdateProcessorCommand> context)
    {
        _logger.LogInformation("Processing UpdateProcessorCommand for ID {Id}", context.Message.Id);

        try
        {
            var existing = await _repository.GetByIdAsync(context.Message.Id);
            if (existing == null)
            {
                _logger.LogWarning("ProcessorEntity with ID {Id} not found for update", context.Message.Id);
                await context.RespondAsync(new { Error = "Entity not found", Success = false });
                return;
            }

            // Update properties
            existing.Name = context.Message.Name;
            existing.Version = context.Message.Version;
            existing.ProcessorType = context.Message.ProcessorType;
            existing.Configuration = context.Message.Configuration ?? new Dictionary<string, object>();
            existing.IsActive = context.Message.IsActive;
            existing.UpdatedBy = context.Message.RequestedBy;

            var updated = await _repository.UpdateAsync(existing);

            await _publishEndpoint.Publish(new ProcessorUpdatedEvent
            {
                Id = updated.Id,
                Name = updated.Name,
                Version = updated.Version,
                ProcessorType = updated.ProcessorType,
                Configuration = updated.Configuration,
                IsActive = updated.IsActive,
                UpdatedAt = updated.UpdatedAt,
                UpdatedBy = updated.UpdatedBy
            });

            await context.RespondAsync(updated);

            _logger.LogInformation("Successfully processed UpdateProcessorCommand for ID {Id}", context.Message.Id);
        }
        catch (DuplicateKeyException ex)
        {
            _logger.LogWarning("Duplicate key error in UpdateProcessorCommand: {Error}", ex.Message);
            await context.RespondAsync(new { Error = ex.Message, Success = false });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing UpdateProcessorCommand for ID {Id}", context.Message.Id);
            throw;
        }
    }
}
```

#### DeleteProcessorCommandConsumer.cs

```csharp
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MassTransit.Commands;
using EntitiesManager.Infrastructure.MassTransit.Events;
using MassTransit;
using Microsoft.Extensions.Logging;

namespace EntitiesManager.Infrastructure.MassTransit.Consumers.Processor;

public class DeleteProcessorCommandConsumer : IConsumer<DeleteProcessorCommand>
{
    private readonly IProcessorEntityRepository _repository;
    private readonly IPublishEndpoint _publishEndpoint;
    private readonly ILogger<DeleteProcessorCommandConsumer> _logger;

    public DeleteProcessorCommandConsumer(
        IProcessorEntityRepository repository,
        IPublishEndpoint publishEndpoint,
        ILogger<DeleteProcessorCommandConsumer> logger)
    {
        _repository = repository;
        _publishEndpoint = publishEndpoint;
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<DeleteProcessorCommand> context)
    {
        _logger.LogInformation("Processing DeleteProcessorCommand for ID {Id}", context.Message.Id);

        try
        {
            var deleted = await _repository.DeleteAsync(context.Message.Id);

            if (deleted)
            {
                await _publishEndpoint.Publish(new ProcessorDeletedEvent
                {
                    Id = context.Message.Id,
                    DeletedAt = DateTime.UtcNow,
                    DeletedBy = context.Message.RequestedBy
                });

                await context.RespondAsync(new { Success = true, Message = "Entity deleted successfully" });
                _logger.LogInformation("Successfully processed DeleteProcessorCommand for ID {Id}", context.Message.Id);
            }
            else
            {
                _logger.LogWarning("ProcessorEntity with ID {Id} not found for deletion", context.Message.Id);
                await context.RespondAsync(new { Success = false, Error = "Entity not found" });
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing DeleteProcessorCommand for ID {Id}", context.Message.Id);
            throw;
        }
    }
}
```

#### GetProcessorQueryConsumer.cs

```csharp
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MassTransit.Commands;
using MassTransit;
using Microsoft.Extensions.Logging;

namespace EntitiesManager.Infrastructure.MassTransit.Consumers.Processor;

public class GetProcessorQueryConsumer : IConsumer<GetProcessorQuery>
{
    private readonly IProcessorEntityRepository _repository;
    private readonly ILogger<GetProcessorQueryConsumer> _logger;

    public GetProcessorQueryConsumer(
        IProcessorEntityRepository repository,
        ILogger<GetProcessorQueryConsumer> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task Consume(ConsumeContext<GetProcessorQuery> context)
    {
        _logger.LogInformation("Processing GetProcessorQuery for ID {Id}", context.Message.Id);

        try
        {
            var entity = await _repository.GetByIdAsync(context.Message.Id);

            if (entity != null)
            {
                await context.RespondAsync(entity);
                _logger.LogInformation("Successfully processed GetProcessorQuery for ID {Id}", context.Message.Id);
            }
            else
            {
                _logger.LogWarning("ProcessorEntity with ID {Id} not found", context.Message.Id);
                await context.RespondAsync(new { Error = "Entity not found", Success = false });
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing GetProcessorQuery for ID {Id}", context.Message.Id);
            throw;
        }
    }
}
```

### 4. Update MassTransit Configuration

**Location**: `src/EntitiesManager/EntitiesManager.Api/Configuration/MassTransitConfiguration.cs`

Add the new consumers to the configuration:

```csharp
// Add consumers (add these lines to the existing consumer registrations)
x.AddConsumer<CreateProcessorCommandConsumer>();
x.AddConsumer<UpdateProcessorCommandConsumer>();
x.AddConsumer<DeleteProcessorCommandConsumer>();
x.AddConsumer<GetProcessorQueryConsumer>();
```

Add the new endpoint configuration:

```csharp
// Configure endpoints (add this to the existing endpoint configurations)
cfg.ReceiveEndpoint("processor-commands", e =>
{
    e.ConfigureConsumer<CreateProcessorCommandConsumer>(context);
    e.ConfigureConsumer<UpdateProcessorCommandConsumer>(context);
    e.ConfigureConsumer<DeleteProcessorCommandConsumer>(context);
    e.ConfigureConsumer<GetProcessorQueryConsumer>(context);
});
```

## OpenTelemetry Integration

### 1. Logging Integration

The logging is automatically handled by the BaseRepository and consumers. The structured logging format includes:

- **Entity Type**: `ProcessorEntity`
- **Operation**: Create, Update, Delete, Get
- **Trace Correlation**: TraceId and SpanId for distributed tracing
- **Structured Attributes**: Entity ID, composite key, operation results

### 2. Trace Instrumentation

The BaseRepository automatically creates traces for all operations:

```csharp
// Example trace creation (already implemented in BaseRepository)
using var activity = ActivitySource.StartActivity($"Create{typeof(T).Name}");
activity?.SetTag("entity.type", typeof(T).Name);
activity?.SetTag("entity.compositeKey", entity.GetCompositeKey());
```

### 3. Event Publishing for Entity Lifecycle

Events are automatically published for all entity lifecycle operations:

- **ProcessorCreatedEvent**: Published when entity is created
- **ProcessorUpdatedEvent**: Published when entity is updated
- **ProcessorDeletedEvent**: Published when entity is deleted

### 4. Metrics Configuration

The OpenTelemetry configuration automatically captures metrics for:

- **HTTP Request Duration**: API endpoint performance
- **Exception Counts**: Error tracking by exception type
- **Process Metrics**: Memory usage, CPU time, GC collections
- **Custom Metrics**: Can be added using `ILogger` with structured logging

## Testing Implementation

### 1. Create Integration Test Base

**Location**: `tests/EntitiesManager.IntegrationTests/ProcessorTests/`

Create `ProcessorIntegrationTestBase.cs`:

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Interfaces.Repositories;
using EntitiesManager.Infrastructure.MongoDB;
using EntitiesManager.Infrastructure.Repositories;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using MongoDB.Driver;
using Testcontainers.MongoDb;

namespace EntitiesManager.IntegrationTests.ProcessorTests;

public abstract class ProcessorIntegrationTestBase : IAsyncLifetime
{
    private readonly MongoDbContainer _mongoContainer;
    protected IMongoDatabase Database { get; private set; } = null!;
    protected IProcessorEntityRepository ProcessorRepository { get; private set; } = null!;
    protected IServiceProvider ServiceProvider { get; private set; } = null!;

    protected ProcessorIntegrationTestBase()
    {
        _mongoContainer = new MongoDbBuilder()
            .WithImage("mongo:7.0")
            .WithPortBinding(27017, true)
            .Build();
    }

    public async Task InitializeAsync()
    {
        await _mongoContainer.StartAsync();

        // Configure BSON serialization
        BsonConfiguration.Configure();

        // Setup MongoDB client and database
        var connectionString = _mongoContainer.GetConnectionString();
        var mongoClient = new MongoClient(connectionString);
        Database = mongoClient.GetDatabase("ProcessorTestDb");

        // Setup service collection
        var services = new ServiceCollection();
        services.AddLogging(builder => builder.AddConsole());
        services.AddSingleton<IMongoClient>(mongoClient);
        services.AddSingleton(Database);

        // Add mock event publisher for testing
        services.AddScoped<IEventPublisher, MockEventPublisher>();
        services.AddScoped<IProcessorEntityRepository, ProcessorEntityRepository>();

        ServiceProvider = services.BuildServiceProvider();
        ProcessorRepository = ServiceProvider.GetRequiredService<IProcessorEntityRepository>();
    }

    public async Task DisposeAsync()
    {
        ServiceProvider?.Dispose();
        await _mongoContainer.DisposeAsync();
    }

    protected ProcessorEntity CreateTestProcessor(string name = "TestProcessor", string version = "1.0.0")
    {
        return new ProcessorEntity
        {
            Name = name,
            Version = version,
            ProcessorType = "DataProcessor",
            Configuration = new Dictionary<string, object>
            {
                ["maxThreads"] = 4,
                ["timeout"] = 30000,
                ["retryCount"] = 3
            },
            IsActive = true,
            CreatedBy = "TestUser"
        };
    }
}

// Mock event publisher for testing
public class MockEventPublisher : IEventPublisher
{
    public Task PublishAsync<T>(T eventData) where T : class
    {
        // Mock implementation - just return completed task
        return Task.CompletedTask;
    }
}
```

### 2. Create Comprehensive CRUD Tests

Create `ProcessorCrudTests.cs`:

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.Core.Exceptions;
using FluentAssertions;

namespace EntitiesManager.IntegrationTests.ProcessorTests;

public class ProcessorCrudTests : ProcessorIntegrationTestBase
{
    [Fact]
    public async Task CreateProcessor_ShouldSucceed_WithValidData()
    {
        // Arrange
        var processor = CreateTestProcessor();

        // Act
        var created = await ProcessorRepository.CreateAsync(processor);

        // Assert
        created.Should().NotBeNull();
        created.Id.Should().NotBe(Guid.Empty);
        created.Name.Should().Be("TestProcessor");
        created.Version.Should().Be("1.0.0");
        created.ProcessorType.Should().Be("DataProcessor");
        created.IsActive.Should().BeTrue();
        created.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, TimeSpan.FromSeconds(5));
        created.CreatedBy.Should().Be("TestUser");
    }

    [Fact]
    public async Task CreateProcessor_ShouldThrowDuplicateKeyException_WhenCompositeKeyExists()
    {
        // Arrange
        var processor1 = CreateTestProcessor();
        var processor2 = CreateTestProcessor(); // Same name and version

        // Act
        await ProcessorRepository.CreateAsync(processor1);

        // Assert
        var exception = await Assert.ThrowsAsync<DuplicateKeyException>(
            () => ProcessorRepository.CreateAsync(processor2));

        exception.Message.Should().Contain("TestProcessor_1.0.0");
    }

    [Fact]
    public async Task GetByIdAsync_ShouldReturnProcessor_WhenExists()
    {
        // Arrange
        var processor = CreateTestProcessor();
        var created = await ProcessorRepository.CreateAsync(processor);

        // Act
        var retrieved = await ProcessorRepository.GetByIdAsync(created.Id);

        // Assert
        retrieved.Should().NotBeNull();
        retrieved!.Id.Should().Be(created.Id);
        retrieved.Name.Should().Be(created.Name);
        retrieved.Version.Should().Be(created.Version);
    }

    [Fact]
    public async Task GetByIdAsync_ShouldReturnNull_WhenNotExists()
    {
        // Arrange
        var nonExistentId = Guid.NewGuid();

        // Act
        var result = await ProcessorRepository.GetByIdAsync(nonExistentId);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task UpdateAsync_ShouldSucceed_WithValidData()
    {
        // Arrange
        var processor = CreateTestProcessor();
        var created = await ProcessorRepository.CreateAsync(processor);

        created.ProcessorType = "UpdatedProcessor";
        created.IsActive = false;
        created.Configuration["newProperty"] = "newValue";
        created.UpdatedBy = "UpdatedUser";

        // Act
        var updated = await ProcessorRepository.UpdateAsync(created);

        // Assert
        updated.Should().NotBeNull();
        updated!.ProcessorType.Should().Be("UpdatedProcessor");
        updated.IsActive.Should().BeFalse();
        updated.Configuration.Should().ContainKey("newProperty");
        updated.UpdatedBy.Should().Be("UpdatedUser");
        updated.UpdatedAt.Should().BeAfter(updated.CreatedAt);
    }

    [Fact]
    public async Task DeleteAsync_ShouldReturnTrue_WhenEntityExists()
    {
        // Arrange
        var processor = CreateTestProcessor();
        var created = await ProcessorRepository.CreateAsync(processor);

        // Act
        var deleted = await ProcessorRepository.DeleteAsync(created.Id);

        // Assert
        deleted.Should().BeTrue();

        // Verify entity is actually deleted
        var retrieved = await ProcessorRepository.GetByIdAsync(created.Id);
        retrieved.Should().BeNull();
    }

    [Fact]
    public async Task DeleteAsync_ShouldReturnFalse_WhenEntityNotExists()
    {
        // Arrange
        var nonExistentId = Guid.NewGuid();

        // Act
        var deleted = await ProcessorRepository.DeleteAsync(nonExistentId);

        // Assert
        deleted.Should().BeFalse();
    }

    [Fact]
    public async Task GetByProcessorTypeAsync_ShouldReturnMatchingProcessors()
    {
        // Arrange
        var processor1 = CreateTestProcessor("Processor1", "1.0.0");
        processor1.ProcessorType = "TypeA";

        var processor2 = CreateTestProcessor("Processor2", "1.0.0");
        processor2.ProcessorType = "TypeA";

        var processor3 = CreateTestProcessor("Processor3", "1.0.0");
        processor3.ProcessorType = "TypeB";

        await ProcessorRepository.CreateAsync(processor1);
        await ProcessorRepository.CreateAsync(processor2);
        await ProcessorRepository.CreateAsync(processor3);

        // Act
        var typeAProcessors = await ProcessorRepository.GetByProcessorTypeAsync("TypeA");

        // Assert
        typeAProcessors.Should().HaveCount(2);
        typeAProcessors.Should().OnlyContain(p => p.ProcessorType == "TypeA");
    }

    [Fact]
    public async Task GetActiveProcessorsAsync_ShouldReturnOnlyActiveProcessors()
    {
        // Arrange
        var activeProcessor = CreateTestProcessor("Active", "1.0.0");
        activeProcessor.IsActive = true;

        var inactiveProcessor = CreateTestProcessor("Inactive", "1.0.0");
        inactiveProcessor.IsActive = false;

        await ProcessorRepository.CreateAsync(activeProcessor);
        await ProcessorRepository.CreateAsync(inactiveProcessor);

        // Act
        var activeProcessors = await ProcessorRepository.GetActiveProcessorsAsync();

        // Assert
        activeProcessors.Should().HaveCount(1);
        activeProcessors.Should().OnlyContain(p => p.IsActive);
        activeProcessors.First().Name.Should().Be("Active");
    }
}
```

### 3. Create API Integration Tests

Create `ProcessorApiTests.cs`:

```csharp
using EntitiesManager.Core.Entities;
using EntitiesManager.IntegrationTests.ApiTests;
using FluentAssertions;
using System.Net;
using System.Net.Http.Json;

namespace EntitiesManager.IntegrationTests.ProcessorTests;

public class ProcessorApiTests : IClassFixture<CustomWebApplicationFactory>
{
    private readonly HttpClient _client;
    private readonly CustomWebApplicationFactory _factory;

    public ProcessorApiTests(CustomWebApplicationFactory factory)
    {
        _factory = factory;
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task CreateProcessor_ShouldReturn201_WithValidData()
    {
        // Arrange
        var processor = new ProcessorEntity
        {
            Name = "ApiTestProcessor",
            Version = "1.0.0",
            ProcessorType = "ApiTest",
            Configuration = new Dictionary<string, object> { ["test"] = "value" },
            IsActive = true
        };

        // Act
        var response = await _client.PostAsJsonAsync("/api/processors", processor);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Created);
        var created = await response.Content.ReadFromJsonAsync<ProcessorEntity>();
        created.Should().NotBeNull();
        created!.Id.Should().NotBe(Guid.Empty);
        created.Name.Should().Be("ApiTestProcessor");
    }

    [Fact]
    public async Task GetProcessor_ShouldReturn200_WhenExists()
    {
        // Arrange - Create a processor first
        var processor = new ProcessorEntity
        {
            Name = "GetTestProcessor",
            Version = "1.0.0",
            ProcessorType = "GetTest",
            IsActive = true
        };

        var createResponse = await _client.PostAsJsonAsync("/api/processors", processor);
        var created = await createResponse.Content.ReadFromJsonAsync<ProcessorEntity>();

        // Act
        var response = await _client.GetAsync($"/api/processors/{created!.Id}");

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var retrieved = await response.Content.ReadFromJsonAsync<ProcessorEntity>();
        retrieved.Should().NotBeNull();
        retrieved!.Id.Should().Be(created.Id);
    }

    [Fact]
    public async Task UpdateProcessor_ShouldReturn200_WithValidData()
    {
        // Arrange - Create a processor first
        var processor = new ProcessorEntity
        {
            Name = "UpdateTestProcessor",
            Version = "1.0.0",
            ProcessorType = "UpdateTest",
            IsActive = true
        };

        var createResponse = await _client.PostAsJsonAsync("/api/processors", processor);
        var created = await createResponse.Content.ReadFromJsonAsync<ProcessorEntity>();

        // Modify the processor
        created!.ProcessorType = "UpdatedTest";
        created.IsActive = false;

        // Act
        var response = await _client.PutAsJsonAsync($"/api/processors/{created.Id}", created);

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var updated = await response.Content.ReadFromJsonAsync<ProcessorEntity>();
        updated.Should().NotBeNull();
        updated!.ProcessorType.Should().Be("UpdatedTest");
        updated.IsActive.Should().BeFalse();
    }

    [Fact]
    public async Task DeleteProcessor_ShouldReturn204_WhenExists()
    {
        // Arrange - Create a processor first
        var processor = new ProcessorEntity
        {
            Name = "DeleteTestProcessor",
            Version = "1.0.0",
            ProcessorType = "DeleteTest",
            IsActive = true
        };

        var createResponse = await _client.PostAsJsonAsync("/api/processors", processor);
        var created = await createResponse.Content.ReadFromJsonAsync<ProcessorEntity>();

        // Act
        var response = await _client.DeleteAsync($"/api/processors/{created!.Id}");

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.NoContent);

        // Verify deletion
        var getResponse = await _client.GetAsync($"/api/processors/{created.Id}");
        getResponse.StatusCode.Should().Be(HttpStatusCode.NotFound);
    }

    [Fact]
    public async Task GetProcessorsByType_ShouldReturnMatchingProcessors()
    {
        // Arrange - Create processors with different types
        var processor1 = new ProcessorEntity
        {
            Name = "TypeTest1",
            Version = "1.0.0",
            ProcessorType = "SpecialType",
            IsActive = true
        };

        var processor2 = new ProcessorEntity
        {
            Name = "TypeTest2",
            Version = "1.0.0",
            ProcessorType = "SpecialType",
            IsActive = true
        };

        await _client.PostAsJsonAsync("/api/processors", processor1);
        await _client.PostAsJsonAsync("/api/processors", processor2);

        // Act
        var response = await _client.GetAsync("/api/processors/by-type/SpecialType");

        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.OK);
        var processors = await response.Content.ReadFromJsonAsync<List<ProcessorEntity>>();
        processors.Should().NotBeNull();
        processors!.Should().HaveCountGreaterOrEqualTo(2);
        processors.Should().OnlyContain(p => p.ProcessorType == "SpecialType");
    }
}
```

### 4. Running Tests with Docker Containers

To run the comprehensive tests:

```bash
# Start infrastructure containers
cd docker && docker-compose up -d

# Run integration tests
dotnet test tests/EntitiesManager.IntegrationTests/ProcessorTests/ --logger "console;verbosity=detailed"

# Run API tests
dotnet test tests/EntitiesManager.IntegrationTests/ProcessorTests/ProcessorApiTests.cs --logger "console;verbosity=detailed"

# Verify OpenTelemetry telemetry collection
docker logs entitiesmanager-otel-collector --tail 50
```

## Step-by-Step Example: ProcessorEntity

### Complete Implementation Checklist

#### ✅ 1. Core Entity (5 minutes)
- [x] Create `ProcessorEntity.cs` in Core/Entities
- [x] Inherit from `BaseEntity`
- [x] Add required `[BsonElement]` attributes
- [x] Implement `GetCompositeKey()` method
- [x] Add validation attributes

#### ✅ 2. Repository Layer (10 minutes)
- [x] Create `IProcessorEntityRepository.cs` interface
- [x] Create `ProcessorEntityRepository.cs` implementation
- [x] Implement abstract methods from `BaseRepository`
- [x] Add entity-specific query methods
- [x] Create MongoDB indexes
- [x] Implement event publishing methods

#### ✅ 3. API Controller (10 minutes)
- [x] Create `ProcessorsController.cs`
- [x] Implement all CRUD endpoints
- [x] Add entity-specific endpoints
- [x] Handle exceptions properly
- [x] Add proper HTTP status codes

#### ✅ 4. MassTransit Integration (15 minutes)
- [x] Create Commands (`ProcessorCommands.cs`)
- [x] Create Events (`ProcessorEvents.cs`)
- [x] Create 4 Consumers in separate folder
- [x] Update MassTransit configuration
- [x] Add endpoint configuration

#### ✅ 5. Configuration Updates (5 minutes)
- [x] Add BSON class map registration
- [x] Register repository in DI container
- [x] Update MassTransit consumer registration

#### ✅ 6. Testing Implementation (20 minutes)
- [x] Create integration test base class
- [x] Create comprehensive CRUD tests
- [x] Create API integration tests
- [x] Add Docker container test setup
- [x] Verify OpenTelemetry integration

### Total Implementation Time: ~65 minutes

### Verification Commands

```bash
# 1. Test REST API
curl -X POST http://localhost:5130/api/processors \
  -H "Content-Type: application/json" \
  -d '{"name":"TestProcessor","version":"1.0.0","processorType":"DataProcessor","isActive":true}'

curl http://localhost:5130/api/processors

# 2. Test Message Bus (using SimpleMessageBusTest pattern)
# Create test client and publish CreateProcessorCommand

# 3. Verify OpenTelemetry
docker logs entitiesmanager-otel-collector --tail 20

# 4. Run Tests
dotnet test tests/EntitiesManager.IntegrationTests/ProcessorTests/
```

## Summary

This manual provides a complete blueprint for adding new entity types to the EntitiesManager microservice. The pattern ensures:

- **Consistency**: All entities follow the same architectural patterns
- **Observability**: Full OpenTelemetry integration with logs, metrics, and traces
- **Testability**: Comprehensive testing with real Docker containers
- **Scalability**: Message bus integration for distributed processing
- **Maintainability**: Clean architecture with proper separation of concerns

Follow this guide step-by-step, and you'll have a fully functional entity type integrated into the microservice with world-class observability and testing coverage.